# Elm PS Bridge

A very rough tool to generate compatible ELm and PS type definitions from a common YAML definition. I intend to use them to communicate through Elm  ports.

## Example

```bash
elm-ps-bridge --input example.yaml --elmOutput Bridge.elm --psOutput Bridge.purs
```

### `example.yaml`

```yaml
Subscription:
- DownloadPasswords
- UpdatePassword:
    foo: Int
    id: Int
Command:
- Hello
```


### `Bridge.purs`

```purescript
-- File auto generated by purescript-bridge! --
module Bridge where

import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', lens, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype)
import Data.Symbol (SProxy(SProxy))

import Prelude

data Command =
    Hello

derive instance genericCommand :: Generic Command _
derive instance newtypeCommand :: Newtype Command _
derive instance eqCommand :: Eq Command
derive instance ordCommand :: Ord Command

--------------------------------------------------------------------------------
_Hello :: Prism' Command Unit
_Hello = prism' (\_ -> Hello) f
  where
    f Hello = Just unit

--------------------------------------------------------------------------------
newtype Subscription_UpdatePassword =
    Subscription_UpdatePassword {
      foo :: Int
    , id :: Int
    }

derive instance genericSubscription_UpdatePassword :: Generic Subscription_UpdatePassword _
derive instance newtypeSubscription_UpdatePassword :: Newtype Subscription_UpdatePassword _
derive instance eqSubscription_UpdatePassword :: Eq Subscription_UpdatePassword
derive instance ordSubscription_UpdatePassword :: Ord Subscription_UpdatePassword

--------------------------------------------------------------------------------
_Subscription_UpdatePassword :: Iso' Subscription_UpdatePassword { foo :: Int, id :: Int}
_Subscription_UpdatePassword = _Newtype

--------------------------------------------------------------------------------
data Subscription =
    DownloadPasswords
  | UpdatePassword Subscription_UpdatePassword

derive instance genericSubscription :: Generic Subscription _
derive instance newtypeSubscription :: Newtype Subscription _
derive instance eqSubscription :: Eq Subscription
derive instance ordSubscription :: Ord Subscription

--------------------------------------------------------------------------------
_DownloadPasswords :: Prism' Subscription Unit
_DownloadPasswords = prism' (\_ -> DownloadPasswords) f
  where
    f DownloadPasswords = Just unit
    f _ = Nothing

_UpdatePassword :: Prism' Subscription Subscription_UpdatePassword
_UpdatePassword = prism' UpdatePassword f
  where
    f (UpdatePassword a) = Just $ a
    f _ = Nothing

--------------------------------------------------------------------------------
```

### `Bridge.elm`

```elm
module Bridge exposing(..)

import Json.Decode
import Json.Encode exposing (Value)
-- The following module comes from bartavelle/json-helpers
import Json.Helpers exposing (..)
import Dict exposing (Dict)
import Set exposing (Set)


type Command  =
    Hello

jsonDecCommand : Json.Decode.Decoder ( Command )
jsonDecCommand =
    let jsonDecDictCommand = Dict.fromList [("Hello", Hello)]
    in  decodeSumUnaries "Command" jsonDecDictCommand

jsonEncCommand : Command -> Value
jsonEncCommand  val =
    case val of
        Hello -> Json.Encode.string "Hello"



type alias Subscription_UpdatePassword  =
   { foo: Int
   , id: Int
   }

jsonDecSubscription_UpdatePassword : Json.Decode.Decoder ( Subscription_UpdatePassword )
jsonDecSubscription_UpdatePassword =
   Json.Decode.succeed (\pfoo pid -> {foo = pfoo, id = pid})
   |> required "foo" (Json.Decode.int)
   |> required "id" (Json.Decode.int)

jsonEncSubscription_UpdatePassword : Subscription_UpdatePassword -> Value
jsonEncSubscription_UpdatePassword  val =
   Json.Encode.object
   [ ("foo", Json.Encode.int val.foo)
   , ("id", Json.Encode.int val.id)
   ]



type Subscription  =
    DownloadPasswords
    | UpdatePassword Subscription_UpdatePassword

jsonDecSubscription : Json.Decode.Decoder ( Subscription )
jsonDecSubscription =
    let jsonDecDictSubscription = Dict.fromList
            [ ("DownloadPasswords", Json.Decode.lazy (\_ -> Json.Decode.succeed DownloadPasswords))
            , ("UpdatePassword", Json.Decode.lazy (\_ -> Json.Decode.map UpdatePassword (jsonDecSubscription_UpdatePassword)))
            ]
    in  decodeSumObjectWithSingleField  "Subscription" jsonDecDictSubscription

jsonEncSubscription : Subscription -> Value
jsonEncSubscription  val =
    let keyval v = case v of
                    DownloadPasswords  -> ("DownloadPasswords", encodeValue (Json.Encode.list identity []))
                    UpdatePassword v1 -> ("UpdatePassword", encodeValue (jsonEncSubscription_UpdatePassword v1))
    in encodeSumObjectWithSingleField keyval val
```
